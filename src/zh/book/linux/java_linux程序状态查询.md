---
editLink: true
---
# linux java 程序排查脚本

## Top命令（实用）

### 查看java 程序使用内存与cpu情况（实用）

语句一：

```
top -o %MEM -b -n 1 | grep java | awk '{print "PID: "$1" \t 虚拟内存: "$5" \t 物理内存: "$6" \t 共享内存: "$7" \t CPU使用率: "$9"% \t 内存使用率: "$10"%"}'

ps -ef|grep java

jps
```

结果：

```
PID: 6252 	 虚拟内存: 14.2g 	 物理内存: 2.9g 	 共享内存: 26768 	 CPU使用率: 0.0% 	 内存使用率: 18.7%
PID: 31363 	 虚拟内存: 5767456 	 物理内存: 467604 	 共享内存: 13700 	 CPU使用率: 0.0% 	 内存使用率: 2.9%
PID: 1259 	 虚拟内存: 6987256 	 物理内存: 126180 	 共享内存: 3600 	 CPU使用率: 0.0% 	 内存使用率: 0.8%
```

### 查询最高消耗程序

```
top -Hp <pid>
```



## lsof命令

### 通过pid查询java程序路径

```
lsof -p 24238 | grep cwd
```

结果：

```
java    24238 dxxuser  cwd       DIR              253,3      4096  5636099 /usr/local/app/gdcredit2/gdcredit_web
```

## jstat命令(实用)-查看gc情况

### 通过pid查询java程序gcutil情况（实用）

```
jstat -gcutil <pid> <interval> <count>

其中，pid是Java进程的进程号，interval是采样间隔时间（单位为毫秒），count是采样次数

jstat -gcutil 7783 1000 100
```

字段说明：

- `S0`: 年轻代中第一个Survivor区的使用比例（百分比）。
- `S1`: 年轻代中第二个Survivor区的使用比例（百分比）。
- `E`: 年轻代中Eden区的使用比例（百分比）。
- `O`: Old代（或称Tenured代）的使用比例（百分比）。
- `M`: 方法区（或称Metaspace）的使用比例（百分比）。
- `CCS`表示压缩类空间的使用率（百分比）
- `YGC`: **年轻代垃圾回收的次数**。
- `YGCT`: 年轻代垃圾回收所花费的时间（秒）。
- `FGC`: **Full GC的次数。**
- `FGCT`: Full GC所花费的时间（秒）。
- `GCT`: 所有垃圾回收所花费的总时间（秒）。

结果：

```
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00  15.22  37.81  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.81  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.81  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.81  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.81  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.81  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.82  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.82  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.82  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
  0.00  15.22  37.82  10.41  95.50  92.32   1261  178.936    39   56.249  235.185
```



### 通过pid查询java程序gc情况

命令：

```
jstat -gc 6252 1000 10
```

字段说明：

- `S0C`：年轻代中第一个Survivor区的大小（字节）。
- `S1C`：年轻代中第二个Survivor区的大小（字节）。
- `S0U`：年轻代中第一个Survivor区已使用的大小（字节）。
- `S1U`：年轻代中第二个Survivor区已使用的大小（字节）。
- `EC`：年轻代中Eden区的大小（字节）。
- `EU`：年轻代中Eden区已使用的大小（字节）。
- `OC`：Old代（或称Tenured代）的大小（字节）。
- `OU`：Old代已使用的大小（字节）。
- `MC`：方法区（或称Metaspace）的大小（字节）。
- `MU`：方法区已使用的大小（字节）。
- `CCSC`：压缩类空间的大小（字节）。
- `CCSU`：压缩类空间已使用的大小（字节）。
- `YGC`：年轻代GC次数。
- `YGCT`：年轻代GC耗时。
- `FGC`：Full GC次数。
- `FGCT`：Full GC耗时。
- `GCT`：GC总耗时。

结果:

```
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
3072.0 2560.0  0.0   1759.7 256512.0 169920.8 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 169922.9 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 169924.9 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 170090.4 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 170090.4 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 170090.4 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 170090.4 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 170090.4 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 170255.9 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
3072.0 2560.0  0.0   1759.7 256512.0 170255.9 10223616.0 2181406.6  145280.0 137534.4 16256.0 14795.7  10293   74.639   8     24.231   98.870
```

## jstack命令(实用)-查看线程情况

`jstack`命令是Java JDK中的一个工具，用于生成Java进程的线程快照。它可以帮助我们了解Java进程中各个线程的状态、堆栈信息，以及锁的情况，通常用于分析Java应用程序的性能问题和死锁情况。

### 通过pid将java程序的线程快照写入文件内 (实用)

```
jstack pid >> pid-stack.txt

jstack 16845 >> 16845-stack.txt

jstack -l 22694 >> 22694-stack.txt 

//其中，-l参数表示打印关于锁的附加信息。执行该命令后，jstack会打印出每个线程的堆栈信息，并在每个线程的堆栈信息下方打印出该线程持有的锁和等待的锁的信息
jstack -l pid >> pid-stack.txt 

//可以将jstack的输出通过管道发送给grep命令进行关键词过滤，从而只显示包含特定关键词的线程堆栈信息。
jstack <pid> | grep "关键词"  >> pid-stack.txt 
```



## jmap命令（实用）-查看内存情况

### 生成Java进程的堆转储快照（heap dump）（生产不建议使用）

**注意：生产dump文件太大，本机无法使用**

```
jmap -dump:format=b,file=heap_dump.bin <pid>
```

这条命令会生成一个Java堆的转储快照，保存为`heap_dump.bin`文件。这个堆转储文件可以用于后续的内存分析和调试。

### 查看Java堆中对象实例的统计信息（实用）

```
jmap -histo <pid> >> pid-object.txt

jmap -histo 7783 >> 7783-object.txt
```

这条命令会打印出Java堆中各个类的对象实例数量和占用内存大小，有助于分析Java进程中的内存使用情况。

结合 `>>`将文件写入文件内

### 查看Java堆中指定对象实例的详细信息

```
jmap -dump:format=b,file=heap_dump.bin <pid> <object_id>
```

可以使用`jmap`命令生成堆转储文件，并通过指定对象实例的ID来查看该对象实例的详细信息。

### 查看Java进程的共享对象映射

```
jmap -clstats <pid>
```

结果：

```
Class Loader                              Classes Bytes   Parent Class Loader
sun.misc.Launcher$AppClassLoader@70dea4e  1232    34423680 sun.misc.Launcher$ExtClassLoader@15db9742
sun.misc.Launcher$ExtClassLoader@15db9742 1486    68628264 null
```

上面的输出中，第一列是类加载器的名称，第二列是该类加载器所加载的类的数量，第三列是该类加载器加载的类占用的内存大小，第四列是该类加载器的父类加载器。

通过`jmap -clstats`命令，我们可以方便地查看Java进程中各个类加载器加载的类的数量、大小和层次关系，有助于定位可能的内存泄漏或类加载器问题。



## netstat 命令

### 查看所有连接详情

```
netstat grep <pid>

netstat grep 22694
```

### 查看各个状态情况

```
netstat -n | awk '/^tcp/ {++State[$NF]} END {for(i in State) print i, State[i]}' 
```

